"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[835],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),h=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=h(n),m=r,g=d["".concat(l,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var h=2;h<i;h++)o[h]=n[h];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4271:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return h},toc:function(){return p},default:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:2},l=void 0,h={unversionedId:"ds-and-system/boyer_moore",id:"ds-and-system/boyer_moore",title:"boyer_moore",description:"Search a pattern in text of 10M characters in less than 2 seconds",source:"@site/docs/ds-and-system/boyer_moore.md",sourceDirName:"ds-and-system",slug:"/ds-and-system/boyer_moore",permalink:"/docs/ds-and-system/boyer_moore",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ds-and-system/boyer_moore.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Custom HashMap in Java",permalink:"/docs/ds-and-system/hashmap"}},p=[{value:"Search a pattern in text of 10M characters in less than 2 seconds",id:"search-a-pattern-in-text-of-10m-characters-in-less-than-2-seconds",children:[{value:"Pattern search by Naive algorithm Big O(n^2)",id:"pattern-search-by-naive-algorithm-big-on2",children:[],level:3},{value:"Understanding the Boyer&#39;s Moore algorithm",id:"understanding-the-boyers-moore-algorithm",children:[],level:3},{value:"Boyer&#39;s Analysis",id:"boyers-analysis",children:[{value:"Array based pattern preprocessing",id:"array-based-pattern-preprocessing",children:[],level:4},{value:"Hashmap based pattern preprocessing",id:"hashmap-based-pattern-preprocessing",children:[],level:4}],level:3},{value:"Caveats of the hashmap preprocessing",id:"caveats-of-the-hashmap-preprocessing",children:[],level:3},{value:"Performance Analysis",id:"performance-analysis",children:[],level:3}],level:2}],c={toc:p};function d(e){var t=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"search-a-pattern-in-text-of-10m-characters-in-less-than-2-seconds"},"Search a pattern in text of 10M characters in less than 2 seconds"),(0,i.kt)("p",null,"String pattern match is one of the most prominent problem in computer science and has various applications like ",(0,i.kt)("inlineCode",{parentName:"p"},"plagarism"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"document search"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"DNA match")," etc\nOne of the frequently, used algorithm for pattern search is ",(0,i.kt)("inlineCode",{parentName:"p"},"Boyer's Moore Algorithm")," which search for a pattern in a given string in BigO(n+m) time."),(0,i.kt)("p",null,"For pattern search using ",(0,i.kt)("inlineCode",{parentName:"p"},"Boyer's Moore Algorithm"),", it is two phase process."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"First, we need to preprocess the pattern "),(0,i.kt)("li",{parentName:"ol"},"Implementing the ",(0,i.kt)("inlineCode",{parentName:"li"},"Boyer's Moore Algorithm")," and use the preprocessed pattern above for alignment. ")),(0,i.kt)("p",null,"Today, I will briefly explain the Boyer's Moore Algorithm and discuss more about the different ways ( two ways ) of ",(0,i.kt)("inlineCode",{parentName:"p"},"pre processing")," the pattern, which impacts how many characters we can skip while finding the pattern."),(0,i.kt)("p",null,"Brief of Boyer's Moore Algorithm\nSuppose we have a string ",(0,i.kt)("inlineCode",{parentName:"p"},"GCAATGCCTATGTGACC")," and the pattern to search is ",(0,i.kt)("inlineCode",{parentName:"p"},"TATGTG")),(0,i.kt)("h3",{id:"pattern-search-by-naive-algorithm-big-on2"},"Pattern search by Naive algorithm Big O(n^2)"),(0,i.kt)("p",null,"If someone ask us to search a pattern in the string then we usually go via ",(0,i.kt)("inlineCode",{parentName:"p"},"naive")," algorithm wherein we place the pattern at the beginning of the string and try to match all characters from left to right\nlike below."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_3.png",src:n(2382).Z,width:"901",height:"125"})),(0,i.kt)("p",null,"If it does not match, we slide the pattern one more character and then try to match like below.\n",(0,i.kt)("img",{alt:"img_4.png",src:n(1944).Z,width:"892",height:"137"})),(0,i.kt)("p",null,"We keep on doing that until, we found the pattern in the string or string is search completely and pattern is not found.\n",(0,i.kt)("img",{alt:"img_5.png",src:n(3087).Z,width:"887",height:"139"})),(0,i.kt)("p",null,"The time complexity of ",(0,i.kt)("inlineCode",{parentName:"p"},"naive")," algorithm is ",(0,i.kt)("inlineCode",{parentName:"p"},"Big O( n^2)")," and search for a pattern may takes upto days if a string is of millions of characters usually in the case of DNA sequence matching ( 3 Billion characters matched usually ) or detecting the plagrism in thousands of thousands docs.  "),(0,i.kt)("p",null,"Here comes the optimised algorithms like ",(0,i.kt)("inlineCode",{parentName:"p"},"Boyer's Moore algorithm"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Rabin Karp Algorithm"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Knuth Algorithm")," etc. "),(0,i.kt)("h3",{id:"understanding-the-boyers-moore-algorithm"},"Understanding the Boyer's Moore algorithm"),(0,i.kt)("p",null,"There are two important steps of pattern matching with Boyer's Moore algorithm"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Pattern will be matched from right to left, instead of left to right like in ",(0,i.kt)("inlineCode",{parentName:"li"},"naive")," algorithm"),(0,i.kt)("li",{parentName:"ol"},"Algorithm try to align the pattern in the string as much as possible unlike ",(0,i.kt)("inlineCode",{parentName:"li"},"naive")," algorithm where it just keep on moving on character by character",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"While matching from right to left, when we encounter the character which is ",(0,i.kt)("inlineCode",{parentName:"li"},"bad character")," then ",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Check if ",(0,i.kt)("inlineCode",{parentName:"li"},"bad character")," exists in the pattern, if yes then shift the pattern toward right to align  ")))))),(0,i.kt)("p",null,"Lets see how Boyer's Moore algorithm works "),(0,i.kt)("p",null,"First we place the pattern at the beginning string and starts matching character by character from ",(0,i.kt)("inlineCode",{parentName:"p"},"right to left"),". If all characters are matched then it is matched otherwise as you can see in the below screenshot, we will stop when we will found the character which does not matched i.e ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),".",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("img",{alt:"img_6.png",src:n(6423).Z,width:"916",height:"139"}),"\nOnce we found the unmatched character ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," then we will try to find the unmatched character i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," in the pattern. If found then we will try to align the pattern accordingly. Thus, we skipped the ",(0,i.kt)("inlineCode",{parentName:"p"},"1 byte")," "),(0,i.kt)("p",null,"Check the below screenshot, as we have aligned the pattern with the unmatched character.\nOnce the pattern is aligned, we compare the characters from ",(0,i.kt)("inlineCode",{parentName:"p"},"right to left")," again. As we start comparing character ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," is the unmatched character. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_7.png",src:n(8170).Z,width:"912",height:"140"})),(0,i.kt)("p",null,"Now, we check if the unmatched character i.e ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," is present in the string from ",(0,i.kt)("inlineCode",{parentName:"p"},"right to left")," in the pattern. As we can see it is not present in the string, so we will aligned the pattern past bad character i.e past ",(0,i.kt)("inlineCode",{parentName:"p"},"C"),"\nHence, here we have skipped ",(0,i.kt)("inlineCode",{parentName:"p"},"5 bytes"),".\nOnce the pattern is aligned, we again perform the comparison character by character. This time, we found the pattern. Check in below screenshot. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_8.png",src:n(7472).Z,width:"892",height:"143"})),(0,i.kt)("p",null,"Hence, you can see, we are keep moving forward in the string to find the matched pattern. Hence, the pattern match algorithm is of ~ BigO(n) where n is the length of the string. "),(0,i.kt)("h3",{id:"boyers-analysis"},"Boyer's Analysis"),(0,i.kt)("p",null,"If you have noticed, then whenever there is a mismatched, then we have to check if the mismatched character does present in the string or not.\nTo find that character we are traversing the pattern backwards i.e.  ",(0,i.kt)("inlineCode",{parentName:"p"},"right to left")," and from the position of the pattern where first mismatched has occured. This steps increase the complexity as we have to traverse all the way backward until\nthat particular mismatched character is found or pattern is emptied, which makes the complexity of BigO(m) where ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," is the length of the pattern.",(0,i.kt)("br",{parentName:"p"}),"\n","There are many ways, you can optimised the above step so that we do not have to traverse the whole pattern backward and somehow we can find whether that bad character is present in the pattern or not and if present then at what position it is present. "),(0,i.kt)("p",null,"Here, I will provide two implementations "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'The first one, which is common and found on many academic websites, lets say it "array based pattern preprocessing"'),(0,i.kt)("li",{parentName:"ol"},'The another one, which is found by me while optimising the algo further. Obviously, it might be already discovered somewhere by someone. Lets say it "hashmap based pattern preprocessing"')),(0,i.kt)("h4",{id:"array-based-pattern-preprocessing"},"Array based pattern preprocessing"),(0,i.kt)("p",null,"Lets assume we have a pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"AABCD"),", then one of the way is like this"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Create the array of 256 char length say ",(0,i.kt)("inlineCode",{parentName:"li"},"badChar[256]")," and initialize it with ",(0,i.kt)("inlineCode",{parentName:"li"},"-1"),". "),(0,i.kt)("li",{parentName:"ol"},"Traverse the pattern from left to right and at the ASCII position of a char write its position in the pattern like ",(0,i.kt)("inlineCode",{parentName:"li"},"badChar[int(pattern[i])] = i"))),(0,i.kt)("p",null,"So basically, ",(0,i.kt)("inlineCode",{parentName:"p"},"badChar")," array would be like this   "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_9.png",src:n(9540).Z,width:"873",height:"116"})),(0,i.kt)("p",null,"Here, if you noticed then you will find that at index ",(0,i.kt)("inlineCode",{parentName:"p"},"65"),", we have written the position of right most ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),".\nWhy is it so ? Consider the below use case"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_10.png",src:n(8732).Z,width:"891",height:"226"})),(0,i.kt)("p",null,"Now, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"badChar")," array, we can directly check if ",(0,i.kt)("inlineCode",{parentName:"p"},"badChar[int(A)] == -1")," then we can directly skip the whole pattern.\nOtherwise, if it is not ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," then the pattern need to be shift right by ",(0,i.kt)("inlineCode",{parentName:"p"},"j - badChar[int(A)]")," bytes. "),(0,i.kt)("p",null,"However, now consider the following case where we might face the issue or wrong number of shifts.\nConsider this pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"AABCDA"),", create the ",(0,i.kt)("inlineCode",{parentName:"p"},"badChar")," array out of this"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_11.png",src:n(614).Z,width:"900",height:"118"})),(0,i.kt)("p",null,"and consider this with matching the pattern "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_12.png",src:n(8015).Z,width:"894",height:"205"})),(0,i.kt)("p",null,"Here, we have got the bad character ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," so "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"First we will check if it even exists in the pattern or not, it can be done by ",(0,i.kt)("inlineCode",{parentName:"li"},"badChar[int(A)]"),". "),(0,i.kt)("li",{parentName:"ol"},"As value is not -1, we need to determine the position of right most 'A' after the position of ",(0,i.kt)("inlineCode",{parentName:"li"},"j"),". We wont be able to do it as while preprocessing we capture the right most ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," i.e at ",(0,i.kt)("inlineCode",{parentName:"li"},"j = 5"),".\nHence, algorithm will do the just one right shift, however if we see, ideally the shift should be of ",(0,i.kt)("inlineCode",{parentName:"li"},"two")," bytes. ")),(0,i.kt)("p",null,"To circumvent this issue, we can do the preprocessing in the below way.    "),(0,i.kt)("h4",{id:"hashmap-based-pattern-preprocessing"},"Hashmap based pattern preprocessing"),(0,i.kt)("p",null,"In this method of preprocessing, we create the hashmap of characters in the pattern and the values would be the values at which all positions this particular char exists in the patter.\nSay we have a pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"AXBCDA")," then we will create the hashamp like this "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-commandline"},"A ---\x3e [5, 0] \nX ---\x3e [1]\nB ---\x3e [2]\nC ---\x3e [3]\nD ---\x3e [4]\n")),(0,i.kt)("p",null,"Now consider the above scenario where it was failing when we used the ",(0,i.kt)("inlineCode",{parentName:"p"},"array based preprocessing pattern"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_12.png",src:n(8015).Z,width:"894",height:"205"})),(0,i.kt)("p",null,"Here, we have got the bad character ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," so "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"First we will check if it even exists in the pattern or not, it can be done by ",(0,i.kt)("inlineCode",{parentName:"li"},'badChar.get("A")'),". "),(0,i.kt)("li",{parentName:"ol"},"As value is not null, we need to determine the position of right most 'A' after the position of ",(0,i.kt)("inlineCode",{parentName:"li"},"j"),". we can simply do it by traversing the value of key ",(0,i.kt)("inlineCode",{parentName:"li"},"A")," and we need to traverse until we find the first value less than the value of ",(0,i.kt)("inlineCode",{parentName:"li"},"j")," and done. ")),(0,i.kt)("p",null,"By this method, for value of ",(0,i.kt)("inlineCode",{parentName:"p"},"j = 2"),", we will get ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," at position ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", hence shift would be ",(0,i.kt)("inlineCode",{parentName:"p"},"j - 0 = 2")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," that we were getting in the above method. "),(0,i.kt)("h3",{id:"caveats-of-the-hashmap-preprocessing"},"Caveats of the hashmap preprocessing"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Use this preprocessing when pattern consist of varied number of characters like ",(0,i.kt)("inlineCode",{parentName:"li"},"text search"),". "),(0,i.kt)("li",{parentName:"ol"},"This preprocessing does not suit when pattern is consist of small number of characters like ",(0,i.kt)("inlineCode",{parentName:"li"},"DNA sequence")," because it will make the value array too long and search within it would be of ",(0,i.kt)("inlineCode",{parentName:"li"},"BigO(m)")," where m is the number of times a character ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," appear in pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"p"),". ")),(0,i.kt)("h3",{id:"performance-analysis"},"Performance Analysis"),(0,i.kt)("p",null,"For performance analysis, I use jprofiler. "),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_13.png",src:n(717).Z,width:"1088",height:"596"})),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Test"),(0,i.kt)("th",{parentName:"tr",align:null},"String length"),(0,i.kt)("th",{parentName:"tr",align:null},"Pattern length"),(0,i.kt)("th",{parentName:"tr",align:null},"Time taken"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"10M characters"),(0,i.kt)("td",{parentName:"tr",align:null},"10000 characters"),(0,i.kt)("td",{parentName:"tr",align:null},"1.8ms")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null}),(0,i.kt)("td",{parentName:"tr",align:null})))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'package com.amit.ds.string;\n\n\nimport java.util.*;\n\nclass BM{\n    \npublic static void main(String args[]) {\n        \n//      Random characters can be generated from here https://onlinerandomtools.com/generate-random-string\n        String inputString = "<ENTER_YOUR_10MB_Characters here>";\n        \n        String patternString = "xkbhntksfl";        \n        \n        int j = patternString.length() - 1;\n        int i = 0;\n        int index = i;\n        HashMap<Character, ArrayList<Integer>> badChar = new HashMap<Character, ArrayList<Integer>>();\n        \n        createBadCharArray(patternString, badChar);\n        int totalShift = 0;\n        int totalLoop = 0;\n        \n        while( i < inputString.length()) {\n                        \n            totalLoop = totalLoop + 1;\n            \n            if ( i < ( patternString.length() - 1)) {\n                \n                \n                i= i + 1;\n                index = i;\n            }\n            \n            else if ( inputString.charAt(index) != patternString.charAt(j)) {\n                \n                \n                Character badCharacter = inputString.charAt(index);\n                \n                if(badChar.get(badCharacter) == null) {\n                    \n                    totalShift = totalShift + j + 1;\n                    i = i + j + 1;\n                }\n                else {\n                    \n                    ArrayList<Integer> xArrayList = badChar.get(badCharacter);\n                    Iterator<Integer> iterator = xArrayList.iterator();\n                    int shift = 0;\n                    \n                    while(iterator.hasNext()) {\n                        \n                        int k = iterator.next();\n                        \n                        if (  k < j ) {\n                            \n                            shift = k;\n                        }\n                        else {\n                            break;\n                        }\n                        \n                    }\n                    \n                    totalShift =  j - shift ;\n                    if (totalShift == 0) {\n                        i= i + 1;\n                    }\n                    else {\n                        i  = i + (j - shift );  \n                    }\n                    \n                    \n                }\n                \n                \n                index = i;\n                j = patternString.length() - 1;\n                \n            }\n            else if(inputString.charAt(index) == patternString.charAt(j)) {\n                \n\n                index = index - 1;\n                j= j- 1; \n                \n                if ( j < 0 ) {\n                    System.out.println("Pattern match found at index"  + (i - patternString.length() + 1));\n                    j = patternString.length() - 1;\n                    \n                    i = i + 1;\n                    index = i;\n                    \n                }\n            }\n        }\n        \n    }\n    \n    public static HashMap<Character, ArrayList<Integer>> createBadCharArray(String pattern, HashMap<Character, ArrayList<Integer>> badCharMap) {\n        \n        for ( int i=0; i< pattern.length(); i++) {\n            ArrayList<Integer> xArrayList = badCharMap.get(pattern.charAt(i));\n            \n            if( xArrayList == null) {\n                xArrayList =  new ArrayList<Integer>();\n                xArrayList.add(i);\n                badCharMap.put(pattern.charAt(i), xArrayList);\n            }\n            else {\n                xArrayList.add(i);\n                badCharMap.get(pattern.charAt(i));\n            }\n        }\n        \n        return badCharMap;\n        \n    }\n//  public static int computeShift(String shiftPattern, String matchedPattern,  char badChar) {\n//      \n//      int shift =  0;\n//      \n//      for (int i=shiftPattern.length() -  1; i >= 0; i--) {\n//          if (shiftPattern.charAt(i) == badChar) {\n//              shift = shift + 1;\n//              break;\n//          }\n//          else {\n//              shift = shift + 1;\n//          }\n//      }\n//      \n//      if ( shift == 0) {\n//          shift = shiftPattern.length();\n//      }\n//      \n//      return shift + matchedPattern.length();\n//      \n//  }\n     \n    \n\n}\n\n\n')))}d.isMDXComponent=!0},8732:function(e,t,n){t.Z=n.p+"assets/images/img_10-02084960dc410fd7d58645e6f17af13a.png"},614:function(e,t,n){t.Z=n.p+"assets/images/img_11-eeb08c89be290a04b8571d2a0bdc12d6.png"},8015:function(e,t,n){t.Z=n.p+"assets/images/img_12-e4c12423855526cc2e049d94b3b104f8.png"},717:function(e,t,n){t.Z=n.p+"assets/images/img_13-7f154104315b577a46601c89781a2822.png"},2382:function(e,t,n){t.Z=n.p+"assets/images/img_3-db84820d2f51817344b246fe657d2d2f.png"},1944:function(e,t,n){t.Z=n.p+"assets/images/img_4-2ee223c0dff7cbbaea4cee1a87393523.png"},3087:function(e,t,n){t.Z=n.p+"assets/images/img_5-4ffce8afcfb9219f40518298d53235e6.png"},6423:function(e,t,n){t.Z=n.p+"assets/images/img_6-44974797883c1b8df80e879cea8781e8.png"},8170:function(e,t,n){t.Z=n.p+"assets/images/img_7-7ac034ef1fb4f30d6dc3ba6f82b13c07.png"},7472:function(e,t,n){t.Z=n.p+"assets/images/img_8-5ecadc11a4eb00dd6bff5ffc8d618634.png"},9540:function(e,t,n){t.Z=n.p+"assets/images/img_9-9371f0f1139064c59a68a833f66f3ab2.png"}}]);